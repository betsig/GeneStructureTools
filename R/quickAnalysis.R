#' Filter out significant events from a whippet diff comparison
#' @param whippetDiff data.frame containing whippet diff data. May be generated by readWhippetDIFFfiles()
#' @param probability minimum probability required to call event as significant
#' @param psiDelta minimum change in psi required to call an event as significant
#' @param eventTypes which event type to filter for? default = "all"
#' @param whippetCounts optional whippet counts data.frame for read count filtering. May be generated by readWhippetPSIfiles()
#' @param minCounts minumum number of counts for all replicates in at least one condition to call an event as significant
#' @return filtered whippet differential comparison data.frame
#' @export
#' @examples
#' @author Beth Signal
filterSignificantWhippetEvents <- function(whippetDiff,
                                           probability = 0.95,
                                           psiDelta = 0.1,
                                           eventTypes = "all",
                                           whippetCounts = NULL,
                                           minCounts = NA,
                                           sampleTable){

    if(eventTypes == "all"){
        eventTypes <- unique(whippetDiff$type)
    }

    significantEvents <- whippetDiff[which(whippetDiff$probability > probability &
                                                 abs(whippetDiff$psi_delta) > psiDelta &
                                                 whippetDiff$type %in% eventTypes),]

    #filter by minimum read counts?
    if(!is.null(whippetCounts) & !is.na(minCounts)){
        m <- match(significantEvents$unique_name, whippetCounts$unique_name)
        n1 <- match(sampleTable$sample[sampleTable$condition %in%
                                                   unique(significantEvents$condition_1)],
                    colnames(whippetCounts))
        n2 <- match(sampleTable$sample[sampleTable$condition %in%
                                                   unique(significantEvents$condition_2)],
                    colnames(whippetCounts))
        significantEvents$condition_1_counts <- rowMeans(whippetCounts[m,n1])
        significantEvents$condition_2_counts <- rowMeans(whippetCounts[m,n2])

        keep <- which(apply(whippetCounts[m,n1], 1, function(x) all(x > minCounts)) |
                          apply(whippetCounts[m,n2], 1, function(x) all(x > minCounts)))

        significantEvents <- significantEvents[keep,]
    }

    return(significantEvents)

}
#' Compare open reading frames for two sets of paired transcripts
#' @param transcriptsX GRanges object with exon annotations for all transcripts to be compared for the 'normal' condition
#' @param transcriptsY GRanges object with exon annotations for all transcripts to be compared for the 'alternative' condition
#' @param g BSGenome object containing the genome for the species analysed
#' @param NMD Use NMD predictions? (Note: notNMD must be installed to use this feature)
#' @param orfPrediction What type of orf predictions to return. default: "all_frames"
#' @return Summarised ORF changes data.frame
#' @export
#' @examples
#' @author Beth Signal
transcriptChangeSummary <- function(transcriptsX,
                                    transcriptsY,
                                    g,
                                    NMD = FALSE,
                                    orfPrediction = "all_frames"){





    if(orfPrediction == "all_frames"){
        orfsX <- getOrfs(transcriptsX, g,returnLongestOnly = FALSE, all_frames = TRUE)
        orfsY <- getOrfs(transcriptsY, g,returnLongestOnly = FALSE, all_frames = TRUE)
    }else{
        orfsX <- getOrfs(transcriptsX, g,returnLongestOnly = TRUE)
        orfsY <- getOrfs(transcriptsY, g,returnLongestOnly = TRUE)
    }

    if(all(!grepl("[+]", orfsX$id))){

        if(orfPrediction == "all_frames"){
            Yid.withFrame <- paste0(unlist(lapply(str_split(orfsY$id, "[+]"),"[[",1)),"_", orfsY$frame)
            Xid.withFrame <- paste0(orfsX$id,"_", orfsX$frame)
            m <- match(Yid.withFrame, Xid.withFrame)
        }else{
            m <- match(unlist(lapply(str_split(orfsY$id, "[+]"),"[[",1)), orfsX$id)
        }

        orfsX<- orfsX[m,]
        orfsX$id <- orfsY$id
        #orfsX <- orfsX[which(!duplicated(orfsX$id)),]
    }

    if(NMD == TRUE){
        orfsX$nmd_prob <- notNMD::predictNMD(orfsX, "prob")
        orfsX$nmd_class <- notNMD::predictNMD(orfsX)
        orfsY$nmd_prob <- notNMD::predictNMD(orfsY, "prob")
        orfsY$nmd_class <- notNMD::predictNMD(orfsY)
    }
    orfsX <- orfsX[which(!is.na(orfsX$orf_length)),]
    orfsY <- orfsY[which(!is.na(orfsY$orf_length)),]

    orfChange <- orfDiff(orfsX, orfsY, filterNMD = NMD)

    if(NMD == TRUE){
        nmdChange <- attrChangeAltSpliced(orfsX,
                                           orfsY,
                                           attribute="nmd_prob",
                                           compareBy="gene",
                                           useMax=FALSE)
        m <- match(orfChange$id, nmdChange$id)
        orfChange <- cbind(orfChange, nmdChange[m,-1])
    }
    return(orfChange)
}

#' Compare open reading frames for whippet differentially spliced events
#' @param significantEvents data.frame containing signficant whippet diff data.
#' @param eventTypes which event type to filter for? default = "all"
#' @param gtf.exons GRanges gtf annotation of exons
#' @param g BSGenome object containing the genome for the species analysed
#' @param whippetJnc whippet junction locations. Only needed if event types include AA/AD/AF/AL.
#' @param NMD Use NMD predictions? (Note: notNMD must be installed to use this feature)
#' @return data.frame containing signficant whippet diff data and ORF change summaries
#' @export
#' @examples
#' @author Beth Signal
whippetTranscriptChangeSummary <- function(significantEvents,
                                           whippetCoords,
                                           eventTypes = "all",
                                           gtf.exons,
                                           g,
                                           whippetJnc,
                                           NMD = FALSE){

    if(eventTypes == "all"){
        eventTypes <- unique(significantEvents$type)
    }

    if(any(eventTypes == "CE") & any(significantEvents$type == "CE")){
        significantEvents.ce <- significantEvents[significantEvents$type=="CE",]

        # get whippet exon coordinates
        ranges.ce <- whippetCoords[whippetCoords$id %in% significantEvents.ce$coord]
        # find exons in the gtf that overlap whippet exons
        exons.ce <- findExonContainingTranscripts(ranges.ce, gtf.exons)
        # make skipped exon transcripts
        skippedExonTranscripts <- removeExonInTranscript(ranges.ce, exons.ce,
                                                         gtf.exons, glueExons = TRUE)
        # make non-skipped exon transcripts
        normalTranscripts <- gtf.exons[gtf.exons$transcript_id %in% exons.ce$transcript_id]

        orfChanges.ce <- transcriptChangeSummary(normalTranscripts,
                                                 skippedExonTranscripts,
                                                 g = g,NMD = NMD)
        # add to significantEvents.ce
        m <- match(significantEvents.ce$coord, orfChanges.ce$id)
        significantEvents.ce <- cbind(significantEvents.ce, orfChanges.ce[m,-1])

        if(exists("SignificantEvents.withORF")){
            SignificantEvents.withORF <- rbind(SignificantEvents.withORF,
                                               significantEvents.ce)
        }else{
            SignificantEvents.withORF <- significantEvents.ce
        }
    }
    if(any(eventTypes == "RI") & any(significantEvents$type == "RI")){
        significantEvents.ri <- significantEvents[significantEvents$type=="RI",]

        # get whippet exon coordinates
        ranges.ri <- whippetCoords[whippetCoords$id %in% significantEvents.ri$coord]
        # need to extend for whippet coords
        start(ranges.ri) <- start(ranges.ri) -1
        end(ranges.ri) <- end(ranges.ri) +1
        # find introns in the gtf that overlap whippet introns
        exons.ri <- findIntronContainingTranscripts(ranges.ri, gtf.exons)
        # add the intron into transcripts
        retainedIntronTranscripts <- addIntronInTranscript(ranges.ri, exons.ri,
                                                           gtf.exons, glueExons = TRUE)
        # make non-retained intron transcripts
        normalTranscripts <- gtf.exons[gtf.exons$transcript_id %in% exons.ri$transcript_id]

        orfChanges.ri <- transcriptChangeSummary(normalTranscripts,
                                                 retainedIntronTranscripts,
                                                 g = g,NMD = NMD)
        # add to significantEvents.ce
        m <- match(significantEvents.ri$coord, orfChanges.ri$id)
        significantEvents.ri <- cbind(significantEvents.ri, orfChanges.ri[m,-1])

        if(exists("SignificantEvents.withORF")){
            SignificantEvents.withORF <- rbind(SignificantEvents.withORF,
                                               significantEvents.ri)
        }else{
            SignificantEvents.withORF <- significantEvents.ri
        }

    }
    if(any(eventTypes %in% c("AA","AD","AF","AL")) &
       any(significantEvents$type %in% c("AA","AD","AF","AL"))){

        events.junctions <- eventTypes[eventTypes %in% c("AA","AD","AF","AL")]
        events.significant <- unique(significantEvents$type)
        events.significant <- events.significant[events.significant %in% events.junctions]

        jncRanges <- formatJunctions(whippetJnc)

        for(e in seq_along(events.significant)){

            event <- events.significant[e]
            significantEvents.jnc <- significantEvents[significantEvents$type==event,]

            # get whippet exon coordinates
            ranges.jnc <- whippetCoords[whippetCoords$id %in% significantEvents.jnc$coord]

            junctionPairs <- findJunctionPairs(ranges.jnc, jncRanges, type=event)

            # make transcripts with alternative junction usage
            altTranscripts <- replaceJunction(junctionPairs, ranges.jnc, gtf.exons, type=event)
            altTranscripts$transcript_id <- paste0(altTranscripts$transcript_id,"+AS ",
                                                   altTranscripts$whippet_id)

            orfChanges.jnc <- transcriptChangeSummary(transcriptsX = altTranscripts[altTranscripts$set=="X"],
                                                    transcriptsY = altTranscripts[altTranscripts$set=="Y"],
                                                     g = g,NMD = NMD)

            # add to significantEvents
            m <- match(significantEvents.jnc$coord, orfChanges.jnc$id)
            significantEvents.jnc <- cbind(significantEvents.jnc, orfChanges.jnc[m,-1])

            if(exists("SignificantEvents.withORF")){
                SignificantEvents.withORF <- rbind(SignificantEvents.withORF,
                                                   significantEvents.jnc)
            }else{
                SignificantEvents.withORF <- significantEvents.jnc
            }
        }

    }

    return(SignificantEvents.withORF)
}
